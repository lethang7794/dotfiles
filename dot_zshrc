# zmodload zsh/zprof

# Inherit PATH from bash
export PATH=$HOME/bin:/usr/local/bin:$PATH

# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell"

# zstyle ':omz:update' mode auto # update automatically without asking
# zstyle ':omz:update' frequency 13

if [ "$(command -v git)" ]; then
  ZSH_CACHE_DIR=$HOME/.cache/zsh
  ZSH_COMPDUMP="$ZSH_CACHE_DIR/.zcompdump-$HOST"
  mkdir -p $ZSH_CACHE_DIR
  source $ZSH/oh-my-zsh.sh
fi

# User configuration

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
# Example Aliases
# #d alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

## argc-completions
# Load argc-completions first, so they can be override by others
export ARGC_COMPLETIONS_ROOT="/home/lqt/go/src/github.com/sigoden/argc-completions"
export ARGC_COMPLETIONS_PATH="$ARGC_COMPLETIONS_ROOT/completions"
export PATH="$ARGC_COMPLETIONS_ROOT/bin:$PATH"
# To add a subset of completions only, change next line e.g. argc_scripts=( cargo git )
argc_scripts=($(ls -p -1 "$ARGC_COMPLETIONS_ROOT/completions" | sed -n 's/\.sh$//p'))
source <(argc --argc-completions zsh $argc_scripts)
# _evalcache argc --argc-completions zsh $argc_scripts
## Brew
HOMEBREW_BIN=/home/linuxbrew/.linuxbrew/bin/brew
if [ -f "$HOMEBREW_BIN" ]; then
  eval "$($HOMEBREW_BIN shellenv)"

  export HOMEBREW_AUTO_UPDATE_SECS="86400"
  # Brew - command-not-found
  HB_CNF_HANDLER="$(brew --repository)/Library/Taps/homebrew/homebrew-command-not-found/handler.sh"
  if [ -f "$HB_CNF_HANDLER" ]; then
    source "$HB_CNF_HANDLER"
  fi
fi

# Antidote - zsh package
ANTIDOTE_BIN="$HOMEBREW_PREFIX/opt/antidote/share/antidote/antidote.zsh"
if [ -f "$ANTIDOTE_BIN" ]; then
  source $ANTIDOTE_BIN
fi
if [ "$(command -v antidote)" ]; then
  zstyle ':antidote:bundle' use-friendly-names 'yes'
  [[ -f ${zsh_plugins:r}.txt ]] || touch ${zsh_plugins:r}.txt
  antidote load ${ZDOTDIR:-$HOME}/.zsh_plugins.txt
fi

# Editor
# EDITOR=/home/linuxbrew/.linuxbrew/bin/micro
EDITOR=nvim

## Zsh plugin

# Globalias
GLOBALIAS_FILTER_VALUES=(ls which z grep dk)

# MichaelAquilina/zsh-you-should-use
# export YSU_MESSAGE_FORMAT="$(tput setaf 1)Hey! I found this %alias_type for %command: %alias$(tput sgr0)"

# Atuin
if [ "$(command -v atuin)" ]; then
  export ATUIN_NOBIND="true"
  # eval "$(atuin init zsh)"
  _evalcache atuin init zsh
  # eval "$(atuin init zsh --disable-up-arrow)"
  # eval "$(atuin init zsh --disable-up-arrow --disable-ctrl-r)"

  # bindkey '^r' atuin-search
  bindkey '^r' atuin-search

  # bind to the up key, which depends on terminal mode
  bindkey '^[[A' atuin-up-search
  bindkey '^[OA' atuin-up-search
fi

# Thefuck
_evalcache thefuck --alias f
# zle -N f        # Define f as a new widget
# bindkey "^[f" f # Bind Alt + f to f

# Starship
if [ "$(command -v starship)" ]; then
  # eval "$(starship init zsh --print-full-init)"
  _evalcache starship init zsh --print-full-init
fi

# Broot
source /home/lqt/.config/broot/launcher/bash/br
function cdd {
  br --only-folders
}
function treeb {
  br -c :pt "$@"
}

## AWS https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-completion.html#cli-command-completion-linux
# autoload bashcompinit && bashcompinit
# autoload -Uz compinit && compinit
# complete -C '/usr/bin/aws_completer' aws

# zoxide: smarter cd
_evalcache zoxide init zsh
zle -N zi        # Define zi as a new widget
bindkey "^[z" zi # Bind Alt + z to zi

# Walk https://github.com/antonmedv/walk
function lk {
  cd "$(walk "$@")"
}

# fzf
if [ -d "$HOMEBREW_PREFIX/opt/fzf" ]; then
  [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
fi

# export FZF_DEFAULT_OPTS="--preview 'bat --color=always {}'"
export FZF_DEFAULT_COMMAND="fd --color=always --hidden"
export FZF_DEFAULT_OPTS="
  --color pointer:white,marker:#87ff00
  --pointer='󰋇 '
  --marker='>'
  --ansi
  --height=~90%
"

# <Ctrl-/> to toggle small preview window to see the full command
# <Ctrl-Y> to copy the command into clipboard using xclip
export FZF_CTRL_R_OPTS="
  --preview 'echo {}' 
  --preview-window up:2:hidden:wrap
  --color header:italic
  --header '<Ctrl-Y> Copy to clipboard\t<Ctrl-/> Toggle preview'
  --bind 'ctrl-/:toggle-preview'
  --bind 'ctrl-y:execute-silent(echo -n {2..} | xclip -selection clipboard)+abort'
"

# export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
# export FZF_CTRL_T_OPTS="
#   --walker-skip .git,node_modules,target
#   --preview 'bat -n --color=always {}'
#   --bind 'ctrl-/:change-preview-window(down|hidden|)'
#   --prompt 'All> ' \
#     --header '<Ctrl-D>: Directories / <Ctrl-F>: Files' \
#     --bind 'ctrl-d:change-prompt(Directories> )+reload(fd --type d)' \
#     --bind 'ctrl-f:change-prompt(Files> )+reload(fd --type f)'
# "
# export FZF_CTRL_T_OPTS="
#   --walker-skip .git,node_modules,target
#   --prompt 'Files> ' \
#   --color header:italic
#   --header '<Ctrl-T>: Switch to Directories/Files' \
#   --bind 'ctrl-t:transform:[[ ! {fzf:prompt} =~ Files ]] &&
#           echo \"change-prompt(Files> )+reload(fd --type file)\" ||
#           echo \"change-prompt(Directories> )+reload(fd --type directory)\"' \
#   --preview '[[ {fzf:prompt} =~ Files ]] && bat --color=always {} || tree -C -L 1 {}' \
#   --bind 'alt-enter:execute(code -g {1}; sleep 1)'
# "

export FZF_CTRL_T_COMMAND="fd --color=always --hidden --type=file --exclude .git"
typeTransformer='
  if [[ ! {fzf:prompt} =~ Files ]]; then
    echo "change-prompt( Files> )+reload(fd --color=always --hidden --type=file --exclude .git)"
  else
    echo "change-prompt( Directories> )+reload(fd --color=always --hidden --type=directory --exclude .git)"
  fi
'
# echo "change-prompt( Directories> )+reload(bfs -color -type d -exclude \( -name .git -or -name pkg -or -name .cache -or -name cache -or -name node_modules \) -unique 2>/dev/null)"
export FZF_CTRL_T_OPTS="
  --walker-skip .git,node_modules,target
  --prompt ' Files> ' \
  --color header:italic
  --header '<Ctrl-T> Switch to Directories/Files' \
  --bind 'ctrl-t:transform:$typeTransformer' \
  --preview '[[ {fzf:prompt} =~ Files ]] && bat --style=header --color=always -- {} || tree -C -L 1 {}' \
  --bind 'alt-enter:execute(code -g {1}; sleep 1)'
"

# export FZF_ALT_C_COMMAND="bfs -type d -nohidden -unique | sed 's|^./||'"
export FZF_ALT_C_COMMAND="bfs -color -type d -unique -exclude \( -name .git -or -name pkg -or -name .cache -or -name cache -or -name node_modules \) 2>/dev/null | sed 's|./||'"
export FZF_ALT_C_OPTS="--preview 'tree -C -L 1 {} | head -200'"

# Switch between Ripgrep mode and fzf filtering mode (Alt-F)
function rg-fzf {
  rm -f /tmp/rg-fzf-{r,f}

  RG_PREFIX="rg --line-number --no-heading --color=always --smart-case --colors=path:style:underline --colors=line:style:underline --colors=line:fg:white --colors=match:style:nobold --colors=match:fg:197,209,222 --colors=match:bg:45,88,156"
  INITIAL_QUERY="${*:-}"

  : | fzf --ansi --disabled --query "$INITIAL_QUERY" \
    --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
    --bind 'alt-f:transform:[[ ! $FZF_PROMPT =~ ripgrep ]] &&
      echo "rebind(change)+change-prompt(1. 󱩾 ripgrep> )+disable-search+transform-query:echo \{q} > /tmp/rg-fzf-f; cat /tmp/rg-fzf-r" ||
      echo "unbind(change)+change-prompt(2. 󰈲 fzf> )+enable-search+transform-query:echo \{q} > /tmp/rg-fzf-r; cat /tmp/rg-fzf-f"' \
    --color "header:italic,hl:-1:underline,hl+:-1:underline:reverse" \
    --color "pointer:white" \
    --prompt '1. 󱩾 ripgrep> ' \
    --delimiter : \
    --header '<Alt-F> Switch to fzf/ripgrep' \
    --preview 'bat --color=always -- {1} --highlight-line {2}' \
    --preview-window 'up,50%,border-bottom,+{2}+3/3,~3' \
    --bind 'enter:execute(nvim {1} +{2})' \
    --bind 'alt-enter:execute(code -g {1}:{2}; sleep 1)'
  # --bind "start:reload:$RG_PREFIX {q}"
}
zle -N rg-fzf        # Define rg-fzf as a new widget
bindkey "^[f" rg-fzf # Bind Alt + f to rg-fzf

function fzf-man-widget {
  batman="man {1} 2>/dev/null | bat --language=man --plain --color=always"

  manlist=$(man -k . | sort | awk -v cyan=$(tput setaf 6) -v blue=$(tput setaf 4) -v res=$(tput sgr0) -v bld=$(tput bold) '{ $1=cyan bld $1; $2=res blue;} 1')
  echo $manlist >/tmp/manlist

  cheatlist=$(cheat -l | awk '{printf "\033[1;36m%s\033[0m %s\n", $1, $3}' | tail --lines +2 | sed 's/community\,*//g' | column -t)
  echo $cheatlist >/tmp/cheatlist

  tldrlist=$(tldr -l)
  echo $tldrlist >/tmp/tldrlist

  executer='
    if [[ {fzf:prompt} =~ Man ]]; then
      echo man {1}
      man {1}
    elif [[ {fzf:prompt} =~ TLDR ]]; then
      echo tldr {1}
      tldr {1}
    else
      echo cheat {1}
      cheat {1}
    fi
  '

  echo $tldrlist |
    fzf \
      -q "$1" \
      --ansi \
      --tiebreak=begin \
      --prompt='󰬛 TLDR > ' \
      --bind "alt-t:+change-preview(tldr --color=always {1})+change-prompt(󰬛 TLDR > )+reload(cat /tmp/tldrlist)" \
      --bind "alt-c:+change-preview(cheat --colorize {1})+change-prompt(󰬊 Cheat > )+reload(cat /tmp/cheatlist)" \
      --bind "alt-m:+change-preview(${batman})+change-prompt(󰬔 Man > )+reload(cat /tmp/manlist)" \
      --bind "enter:become($executer)" \
      --preview "tldr --color=always {1}" \
      --preview-window '50%,rounded,<50(up,85%,border-bottom)' \
      --color header:italic \
      --header '<Alt-T> tldr      <Alt-C> Cheat      <Alt-M> Man'

  zle reset-prompt
}
# `Alt-H` keybinding to launch the widget (this widget works only on zsh, don't know how to do it on bash and fish (additionaly pressing`ctrl-backspace` will trigger the widget to be executed too because both share the same keycode)
zle -N fzf-man-widget
bindkey '^[h' fzf-man-widget

zstyle ":fzf-tab:*" fzf-flags --height="~90%" --header="<Ctrl-Y> Copy to clipboard    <Ctrl-/> Toggle preview" --color header:italic
zstyle ':fzf-tab:*' continuous-trigger '/'

zstyle ':fzf-tab:complete:*' fzf-bindings \
  'ctrl-/:toggle-preview' \
  'ctrl-y:execute-silent(echo -n {2..} | xclip -selection clipboard)+abort'

# zstyle ':completion:*' sort true

# disable sort when completing `git checkout`
# zstyle ':completion:*:git-checkout:*' sort false

# set descriptions format to enable group support
# NOTE: don't use escape sequences here, fzf-tab will ignore them
# zstyle ':completion:*:descriptions' format '[%d]'

# set list-colors to enable filename colorizing
# zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
# zstyle ':completion:*' menu no

# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'tree -C -L 1 $realpath | head -200'

# switch group using `<` and `>`
# zstyle ':fzf-tab:*' switch-group '<' '>'

# Remove the default of run-help being aliased to man
unalias run-help
# Use zsh's run-help, which will display information for zsh builtins.
autoload run-help

# bat: color man. help
if [ "$(command -v bat)" ]; then
  export BAT_THEME=Dracula
  export BAT_CONFIG_PATH="~/.config/bat/config"

  alias bathelp="bat -pl help"
  function man() {
    /usr/bin/man "$@" | bat -pl help
  }

  # alias -g -- -h='-h 2>&1 | bat -pl help'
  # alias -g -- --help='--help 2>&1 | bat -pl help'

  # pre_validation() {
  #   local command="$1"

  #   # Check if the first argument is "help"
  #   if [[ "$command" == *'help'* ]]; then
  #     # Pipe the output of the command to cat
  #     eval $command | bat -pl help
  #     echo "🚨🚨🚨 Press Ctrl+C to exit 🚨🚨🚨"
  #     read -sk key
  #   fi
  # }

  # # Enable the preexec hook
  # autoload -Uz add-zsh-hook
  # add-zsh-hook preexec pre_validation
fi

# fx
# source <(fx --comp zsh) # Need to disable argc-complete for fx; Not so smooth when first release (v33)

# Alias
alias p="pnpm"
# alias b="br"
alias vi="nvim"
alias vim="nvim"
alias help="bat -pl help"
alias ladder="ladder -r https://t.ly/14PSf"
alias mk="minikube"
# alias upd="sudo dnf update -y --refresh && flatpak update && brew update && brew upgrade"

function upd() {
  echo "\n🆕 Update dnf packages"
  sudo dnf upgrade -y --refresh
  # sudo dnf upgrade -y

  echo "\n🆕 Update zsh plugins"
  antidote update

  echo "\n🆕 Update flatpak packages"
  flatpak update -y

  echo "\n🆕 Update Homebrew packages"
  brew update && brew upgrade

}

if [ "$(command -v kubecolor)" ]; then
  alias kubectl="kubecolor"
  compdef kubecolor=kubectl
fi

alias "kube-tree"="kube-lineage"

# Volta
# export VOLTA_HOME="$HOME/.volta"
# export PATH="$VOLTA_HOME/bin:$PATH"

# NVMD
# export NVMD_DIR="$HOME/.nvmd"
# export PATH="$NVMD_DIR/bin:$PATH"

# pnpm
# export PNPM_HOME="/home/lqt/.local/share/pnpm"
# case ":$PATH:" in
# *":$PNPM_HOME:"*) ;;
# *) export PATH="$PNPM_HOME:$PATH" ;;
# esac
# pnpm end

# awsume
alias awsume=". awsume"

# Golang
export PATH="$PATH:$HOME/go/bin"

# gobrew
export PATH="$HOME/.gobrew/current/bin:$HOME/.gobrew/bin:$PATH"
export GOROOT="$HOME/.gobrew/current/go"

# Go cover https://dave.cheney.net/2013/11/14/more-simple-test-coverage-in-go-1-2
go-cover() {
  t=$(mktemp)
  go test $COVERFLAGS -coverprofile=$t $@ && go tool cover -func=$t && unlink $t
}
go-cover-web() {
  t=$(mktemp)
  go test $COVERFLAGS -coverprofile=$t $@ && go tool cover -html=$t && unlink $t
}

# JetBrains
export PATH="$PATH:$HOME/.local/share/JetBrains/Toolbox/scripts"

# VS Code
VSCODE_PROFILE=Fedora
function code {
  /usr/bin/code "$@" --profile $VSCODE_PROFILE
}

# rbenv
if [ "$(command -v rbenv)" ]; then
  _evalcache rbenv init - zsh
fi

# Mojo
export MODULAR_HOME="/home/lqt/.modular"
export PATH="/home/lqt/.modular/pkg/packages.modular.com_mojo/bin:$PATH"

# tmux
# if command -v tmux &> /dev/null && [ -n "$PS1" ] && [[ ! "$TERM" =~ screen ]] && [[ ! "$TERM" =~ tmux ]] && [ -z "$TMUX" ]; then
#   exec tmux
# fi

alias tmux-cleanup-sessions="tmux list-sessions | grep -v attached | awk 'BEGIN{FS=\":\"}{print $1}' | xargs -n 1 tmux kill-session -t 2> /dev/null || (echo 'Cleanup unattached sessions!' && tmux ls)"
alias tmux-cleanup-windows="tmux list-windows | grep -v attached | awk 'BEGIN{FS=\":\"}{print $1}' | xargs -n 1 tmux kill-window -t 2> /dev/null || (echo 'Cleanup unattached windows!' && tmux ls)"
alias open=nautilus

export WHERE=.zshrc

## Functions
function touchfile() {
  local file="$1"
  mkdir -p -- "$(dirname -- "$file")" &&
    touch -- "$file"
}

REPOS="$HOME/go/src/github.com/lethang7794"
GITHUB="$HOME/go/src/github.com"
alias repos="cd $REPOS"
# alias gh="cd $GITHUB"
alias github="cd $GITHUB"

function ghclone() {
  local repo="$1"

  if (($# == 0)); then
    echo "Usage: ghclone ORG/REPO"
    return 1
  fi

  shift 1
  local rest="$@"

  if [[ -z "${repo}" ]]; then
    echo "Usage: ghclone ORG/REPO"
  fi

  local clone_url="git@github.com:$repo"
  local dest="$GITHUB/$repo"

  # Check if destination directory already exists
  if [ -d "$dest" ] && [ -d "$dest/.git" ]; then
    echo "You've already cloned this repo at: $dest"
    echo "Happy hacking, again! 🎮 ૮ ˶ᵔ ᵕ ᵔ˶ ა"
    cd "$dest"
    return 1
  fi

  # Clone the repository
  echo "Cloning 󰊤  /$repo"
  git clone $rest "$clone_url" "$dest" && echo "Happy hacking! 🚀 (づ｡◕‿‿◕｡)づ" && cd "$dest"
}
# compdef ghclone="git" # How to use completions of git clone?

timezsh() {
  shell=${1-$SHELL}
  for i in $(seq 1 10); do /usr/bin/time $shell -i -c exit; done
}

# Created by `pipx` on 2024-04-01 17:04:47
export PATH="$PATH:/home/lqt/.local/bin"

## yazi: Blazing fast terminal file manager
function yy() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}

# Temp workaround to disable punycode deprecation logging to stderr
# https://github.com/bitwarden/clients/issues/6689
alias bw='NODE_OPTIONS="--no-deprecation" bw'

## Copy - paste
# Copy from https://stackoverflow.com/a/62517779 with some modifications
if grep -q -i microsoft /proc/version; then
  # on WSL: version contains the string "microsoft"
  alias copy="clip.exe"
  alias paste="powershell.exe Get-Clipboard"
elif [[ "$(uname -a)" == *"cygwin"* ]]; then
  # on CYGWIN: uname contains the string "cygwin"
  alias copy="/dev/clipboard"
  alias paste="cat /dev/clipboard"
elif [[ ! -r /proc/version ]]; then
  # on MAC: version is not readable at all
  alias copy="pbcopy"
  alias paste="pbpaste"
else
  # on "normal" linux
  alias copy="xclip -sel clip"
  alias paste="xclip -sel clip -o"
fi

# asdf - Extendable version manager with support for Ruby, Node.js, Elixir, Erlang & more
# . "$HOMEBREW_PREFIX/opt/asdf/libexec/asdf.sh"

# Mise-en-place
if [ "$(command -v mise)" ]; then
  # eval "$(mise activate zsh)"
  _evalcache mise activate zsh
fi

# nav
# nav bindkeys

# zprof
